//____________________________________________________________________________
/*!

\class    GasTPCProcessorManager

\author   Yordan Karadzhov <Yordan.Karadzhov \at cern.ch>
	  University of Geneva

\author	  Tom Stainer <tstainer \at liv.ac.uk>
          University of Liverpool

\author   Georgios Christodoulou <georgios at hep.ph.liv.ac.uk>
          University of Liverpool

\created  Sep 2012
\last update Oct 2015
*/
//____________________________________________________________________________
#include "GasTPCProcessorManager.hh"
#include "GasTPCException.hh"

GasTPCProcessorManager::GasTPCProcessorManager() : fileSet(false),datafile_(NULL){
  this->startup();
}

GasTPCProcessorManager::~GasTPCProcessorManager(){
   if(datafile_)
     delete datafile_;
}

void  GasTPCProcessorManager::setFile(std::string filename){
  if(fileSet)return;
  datafile_ = new TFile(filename.c_str(), "RECREATE");
  fileSet=true;
  std::cout << "\n************** Going to write to " << filename << "\n" <<std::endl;
}

void GasTPCProcessorManager::initialize(std::string outputFileName, int verbose) {
  verbose_ = verbose;
  this->setFile(outputFileName);
}

void GasTPCProcessorManager::addProcessor(GasTPCProcessor* a) {
  a->SetFilePtr(datafile_);
  a->initOutDataTree();
  data_.push_back(a->getOutDataTree());
  processors_.push_back(a);
}

void GasTPCProcessorManager::printToStream(ostream& stream) {
  stream << "-------- Processors -------" << std::endl;
  for(unsigned int i=0; i<processors_.size(); i++) {
    stream << processors_[i]->getName() << std::endl;
    //data_[i]->Print(); stream << std::endl;
  }
  stream << "---------------------------" << std::endl;
}

void GasTPCProcessorManager::go() {
  // Check the number of the loaded processors.
  if (!processors_.size()) {
    string mesage = "No processors loaded.";
    string location = "void GasTPCProcessorManager::go()";
    throw GasTPCException(mesage, location, GasTPCException::FATAL);
  }

  // Do the main loop over the loaded processors. 
  int nProcessors = processors_.size();
  int iproc = 0;
  int nIterations_ = 0;
  //loop through the processors
  while (iproc<nProcessors) {
    std::cout << "INFO::Processing " <<processors_[iproc]->getName() << std::endl;
    int ientry = 0;
    if (processors_[iproc]->getName() == "LoadNuEventProcessor"){
      LoadNuEventProcessor * eventProcessor = (LoadNuEventProcessor*)processors_[iproc];
      nIterations_ = eventProcessor->getNEvents();
      //if(eventProcessor->getMinEvents() > 0)
      //ientry = eventProcessor->getMinEvents();
    }
    else if (processors_[iproc]->getName() == "MemTestProcessor"){
      MemTestProcessor *memProcessor = (MemTestProcessor*)processors_[iproc];
      nIterations_ = memProcessor->GetNEntries();
    }

    std::cout << "INFO::Number of iterations to be processed : " << nIterations_ << std::endl;
    //std::cout << "corresponds to exposure of : " << exposure_ << std::endl;

    // If this is not the very first processor, load the input data tree. 
    if (iproc > 0) {
     processors_[iproc]->setInDataTreePtr(data_[iproc-1]);
     processors_[iproc]->loadInDataTree();
    }
    //data_[iproc]->Print();
    //int ientry = 0;

    //if geant is set with the particle gun then ignore loop
    //if (processors_[iproc]->getName() == "Geant4TrackingProcessor") {
    //if(processors_[iproc]->getGunOption()) break;
    //}

    //loop over each processor
    while(ientry<nIterations_) {
      //only record the entry when the process returns true
      if ( processors_[iproc]->process() ){
	ientry++;
	//if(processors_[iproc]->getVerbose()<0){
	//if(ientry==0)std::cout << "\nProcessor :" << processors_[iproc]->getName() << " progress\n";
	//this->progressBar(ientry,nIterations_,0,100);
	//}
      }	
    }
    //data_[iproc]->Print();

    ///call the destructor of each processor
    delete processors_[iproc];

    // Set the number of executions for the next processor according to the number
    // of data entries generated by this processor.
    nIterations_ = data_[iproc]->GetEntries();
    std::cout << "INFO::Number of data entries generated from : " << nIterations_ << std::endl << std::endl;

    iproc++;
  }
}

void GasTPCProcessorManager::write() {

  if(fileSet){
    // Open output root file
    datafile_->SetCompressionLevel(9);
    datafile_->cd();

    // Create and set run stats
    RunStats stats;
    //write to tree
    for(unsigned int d=0; d<data_.size(); d++) {
    	//getData(d)->Print();
    	TTree *tree = getData(d);
    	if (!tree->GetEntries() ) {
	  string mesage = "Data Tree " + string(tree->GetName()) + " is empty or corrupted.";
	  string location = "void GasTPCProcessorManager::write()";
	  throw GasTPCException(mesage, location, GasTPCException::FATAL);
    	}

    	tree->Write("", TObject::kOverwrite);
    	stringstream ss;
    	ss << d << " " << tree->GetTitle();
    	//ss << d << " " << getData(d)->GetTitle();
    	stats.setStat(ss.str(), (int)tree->GetEntries());
    }
    stats.printToStream(cout);

    datafile_->Close();
  }
  else std::cout << "\nERROR: No file set! " << std::endl;
}

// Process has done i out of n rounds,
// and we want a bar of width w and resolution r.
inline void GasTPCProcessorManager::progressBar(int x, int n, int r, int w){
    
    //set r to zero to enable default refresh rate to every 1000th iteration
    if (r == 0) r = n*0.001;

    if (r < n) r =n;

    // Only update r times.
    if ( x % (n/r) != 0 ) return;
 
    // Calculuate the ratio of complete-to-incomplete.
    float ratio = x/(float)n;
    int   c     = ratio * w;
 
    // Show the percentage complete.
    printf("Progress: [%3f%%] [", (float)(ratio*100.) );
 
    // Show the load bar.
    for (int x=0; x<c; x++)
       printf("=");
 
    for (int x=c; x<w; x++)
       printf(" ");
 
    // ANSI Control codes to go back to the
    // previous line and clear it.
    printf("]\n\033[F\033[J");
    //printf("\r");
}

void GasTPCProcessorManager::startup(){

  std::cout << "\n\t\t  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
 	    << "\n\t\t %%                                       		    %%  %"
	    << "\n\t\t%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    %"
	    << "\n\t\t%%	____*				 		    %%  %"
	    << "\n\t\t%%	   \\____*     /**----+		 		    %%  %"
	    << "\n\t\t%%	        \\____/         	 		    %%  %"
	    << "\n\t\t%%	  	     \\/* 	 	 		    %%  %"
	    << "\n\t\t%%					 		    %%  %"
	    << "\n\t\t%%		  	  SoftLAND	  	  	    %%  %"
	    << "\n\t\t%%  (Simulation sOFTware for LBNF-GasTPC Near Detector )      %%  %"
	    << "\n\t\t%%	  	 			  		    %%  %"
	    << "\n\t\t%%					  		    %%  %"
	    << "\n\t\t%%  Georgios Christodoulou, Yordan Karadzhov and Tom Stainer  %%  %"
	    << "\n\t\t%%	  					 	    %%  %"
	    << "\n\t\t%%	 						    %%  %"
	    << "\n\t\t%%					 	            %%  %"
	    << "\n\t\t%%					  		    %%  %"
 	    << "\n\t\t%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n" << std::endl;

}


